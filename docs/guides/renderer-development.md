# レンダラー開発ガイド

独自のWebフレームワークやネイティブプラットフォーム（iOS, Androidなど）向けに、新しいA2UIレンダラー（クライアントライブラリ）を構築したい開発者のためのガイドです。

## レンダラーの責務

レンダラーには、以下の主要な能力が求められます：

1.  **メッセージ受信とバッファリング**: ストリーミングされたJSONLメッセージを正しく受け取り、処理待ちのリストに登録する。
2.  **プロトコルの解釈**: A2UIのメッセージタイプ（`surfaceUpdate` など）を理解し、現在の状態（State）に反映する。
3.  **隣接リストの管理**: IDベースで管理されたコンポーネントの親子関係を、プラットフォームのUIツリーに変換する。
4.  **データバインディングの実装**: JSON Pointerパスを監視し、データモデルが更新された際にUIを動的に更新する（リアクティブな動作）。
5.  **ライフサイクルイベントの処理**: コンポーネントの表示、更新、削除を管理する。

## 実装ステップ

### 1. メッセージプロセッサの作成

JSONメッセージを受け取り、内部の「サーフェス」オブジェクトの状態を管理するハブを作成します。

### 2. コンポーネントカタログの定義

A2UIのコンポーネントタイプ（例：`Text`）を、対応するプラットフォームのウィジェット（例：Flutterの `Text` やHTMLの `<span>`）に変換するためのマップを作成します。

### 3. バインディングエンジンの実装

`path` プロパティを持つコンポーネントが、データモデルの特定の値が変更されたことを検知して再描画（Re-render）する仕組みを実装します。

### 4. アクションとイベントの送信

ユーザーとの対話（ボタンクリックなど）を検知し、エージェントに送り返すためのアクションプロバイダーを実装します。

## 重要な課題：隣接リストのレンダリング

ツリー構造ではなくフラットなリストであるため、ルート ID から再帰的に辿ってUIツリーを構築する必要があります。

```typescript
// 簡略化された擬似コード
function renderComponent(componentId, allComponents) {
  const data = allComponents[componentId];
  const componentType = getComponentType(data);
  const children = data.children.map(id => renderComponent(id, allComponents));
  
  return createNativeWidget(componentType, data.props, children);
}
```

## パフォーマンスの考慮事項

- **差分更新**: すべてを再描画するのではなく、変更があったコンポーネントのみを更新してください。
- **遅延レンダリング**: 画面外の要素や、まだデータが揃っていない要素の処理を最適化してください。
- **メモリ管理**: `deleteSurface` が呼ばれた際、関連するすべてのリソースを解放してください。

## 適合性テスト

新しいレンダラーが正しく動作しているか確認するために：

✅ すべての標準コンポーネントを表示できるか？
✅ 複雑にネストされた隣接リストを正しく構築できるか？
✅ リアルタイムの `dataModelUpdate` がUIに反映されるか？
✅ ユーザー入力が正しくデータモデルを更新し、サーバーに送信されるか？
✅ ダークモードやレスポンシブデザインに対応できるか？

## 次のステップ

- **[ロードマップ](../roadmap.md)**：現在進行中の他のレンダラーを確認し、重複を避ける。
- **[プロトコル詳細](../reference/messages.md)**：完全なメッセージ仕様の理解。
- **[既存のコードを読み解く](https://github.com/google/A2UI/tree/main/renderers)**：AngularやLitの実装は良い参考になります。
